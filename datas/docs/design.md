# 框架设计

* SMNRPC

SureMoonRPC是一个同步的跨语言RPC框架（目前支持GO和C++），在本项目中用来作为控制器。

* 文件接口

见fileitf/file.go，不负责文件的传输，只提供操作号。

* 工作流程
   
1. 上传
调用CreateFile取得fileCode
调用Write取得操作通行码
之后使用通行码传输数据

2. 下载
调用OpenFile取得fileCode
调用Read取得操作通行码
之后使用通行码传输数据

* 代码中使用的非通用名词

|名称|意义|注意|
|-|-|-|
|fileCode|文件的唯一标识码|由服务端生成，不要对其做任何假设|
|block|本项目中的读写都是基于块的|约束见[block](#j_block)|
|subHash,preHash|在读写块的时候会用到，在下面会详细解释|详情见[block](#j_block)|


* <h2 id="j_block">关于block</h2>

类似bt多渠道下载文件的构想,于是提供了可验证的block.参考区块链的思路每一个块都保存上一个块的子
hash和经过这个块之后的计算hash(稍后会详细解释这个,总之是一种验证方式).

摘要算法以sha256为例,首先它提供了8个hash初值,最后的hash值就算直接使用这8个hash初值的十六进制,所以你也可以认为是提供了一个初始hash.
之后它会将消息分解为数个512bit大小的块(实际上还有补位的操作,但那不是本文的重点),随后算法会依次操作每一个块,对sha256算法的详情感兴趣
的同学可以去查看其实现,总之这个过程是以上一个块产生的preHash(对初始块而言是初始hash)和这个块的512bit的数据为参数产生一个新的subHash.
在实际的生产环境中会将每个块的大小设置为512bit的整数倍,preHash和subHash的含义分别变成生产块的preHash和最后一个块的subHash.

通过上述原理,可以生成一个验证摘要文件,将一个大文件描述为一个块链,这样每下载完一个块都可以验证其正确性.

* 共享性

不可信的单点服务器不需要存储完整的文件便可以提供高可信的下载,之类的么...
